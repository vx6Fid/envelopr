package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/vxF6id/envelopr/backend/auth"
	"github.com/vxF6id/envelopr/backend/graph/model"
	"golang.org/x/crypto/bcrypt"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, username string, password string) (*model.AuthPayload, error) {
	var user model.User
	var hashedPassword string

	err := r.DB.QueryRow(`
		SELECT id, username, created_at, password_hash
		FROM users
		WHERE username = $1`, username).Scan(
		&user.ID,
		&user.Username,
		&user.CreatedAt,
		&hashedPassword,
	)

	if err != nil {
		return nil, fmt.Errorf("invalid credentials")
	}

	if err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password)); err != nil {
		return nil, fmt.Errorf("invalid credentials")
	}

	// Generate the token without the expiration time (since GenerateToken no longer returns it)
	token, err := auth.GenerateToken(user.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to generate token")
	}

	return &model.AuthPayload{
		Token:        token, // The token generated for the user
		TokenExpires: "",    // No longer return expiresAt, as it's not part of GenerateToken's return
		User:         &user,
	}, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, username string, password string) (*model.AuthPayload, error) {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password")
	}

	id := uuid.New()
	createdAt := time.Now()

	_, err = r.DB.Exec(`
		INSERT INTO users (id, username, created_at, password_hash)
		VALUES ($1, $2, $3, $4)`,
		id, username, createdAt, hashedPassword,
	)
	if err != nil {
		return nil, fmt.Errorf("username already exists")
	}

	user := &model.User{
		ID:        id.String(),
		Username:  username,
		CreatedAt: createdAt.Format(time.RFC3339),
	}

	// Generate the token without the expiration time (since GenerateToken no longer returns it)
	token, err := auth.GenerateToken(user.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to generate token")
	}

	return &model.AuthPayload{
		Token:        token, // The token generated for the user
		TokenExpires: "",    // No longer return expiresAt, as it's not part of GenerateToken's return
		User:         user,
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context) (*model.AuthPayload, error) {
	userID, ok := auth.ForContext(ctx)
	if !ok {
		return nil, fmt.Errorf("authentication required")
	}

	var user model.User
	err := r.DB.QueryRow(`
        SELECT id, username, created_at
        FROM users
        WHERE id = $1`, userID).Scan(
		&user.ID,
		&user.Username,
		&user.CreatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("user not found")
	}

	token, err := auth.GenerateToken(user.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to generate token")
	}

	return &model.AuthPayload{
		Token:        token,
		TokenExpires: "", // Remove if not using expiration
		User:         &user,
	}, nil
}

// UploadFile is the resolver for the uploadFile field.
func (r *mutationResolver) UploadFile(ctx context.Context, name string, content string) (*model.File, error) {
	userID, ok := auth.ForContext(ctx)
	if !ok {
		return nil, fmt.Errorf("authentication required")
	}

	ownerUUID, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID")
	}

	id := uuid.New()
	createdAt := time.Now()

	_, err = r.DB.Exec(`
		INSERT INTO files (id, name, content, owner, created_at, is_public)
		VALUES ($1, $2, $3, $4, $5, $6)`,
		id, name, content, ownerUUID, createdAt, false,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to upload file: %v", err)
	}

	return &model.File{
		ID:        id.String(),
		Name:      name,
		Owner:     userID,
		CreatedAt: createdAt.Format(time.RFC3339),
		IsPublic:  false,
	}, nil
}

// UpdateFile is the resolver for the updateFile field.
func (r *mutationResolver) UpdateFile(ctx context.Context, id string, name *string) (*model.File, error) {
	userID, ok := auth.ForContext(ctx)
	if !ok {
		return nil, fmt.Errorf("authentication required")
	}

	fileUUID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid file ID")
	}
	userUUID, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID")
	}

	// Verify ownership
	var isOwner bool
	err = r.DB.QueryRow(`
		SELECT EXISTS (
			SELECT 1 FROM files
			WHERE id = $1 AND owner = $2
		)`, fileUUID, userUUID).Scan(&isOwner)
	if err != nil || !isOwner {
		return nil, fmt.Errorf("unauthorized: only owner can update file")
	}

	// Build update query
	var updates []string
	var args []any

	if name != nil {
		updates = append(updates, "name = $1")
		args = append(args, *name)
	}

	if len(updates) == 0 {
		return nil, fmt.Errorf("no fields provided for update")
	}

	args = append(args, fileUUID)
	query := fmt.Sprintf(
		"UPDATE files SET %s WHERE id = $%d",
		strings.Join(updates, ", "),
		len(args),
	)

	_, err = r.DB.Exec(query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to update file")
	}

	var file model.File
	err = r.DB.QueryRow(`
		SELECT id, name, owner, created_at, is_public
		FROM files
		WHERE id = $1`, fileUUID).Scan(
		&file.ID,
		&file.Name,

		&file.Owner,
		&file.CreatedAt,
		&file.IsPublic,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch updated file")
	}

	return &file, nil
}

// UpdateFileContent is the resolver for the updateFileContent field.
func (r *mutationResolver) UpdateFileContent(ctx context.Context, id string, content string) (*model.File, error) {
	userID, ok := auth.ForContext(ctx)
	if !ok {
		return nil, fmt.Errorf("authentication required")
	}

	fileUUID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid file ID")
	}

	// Check access: owner or shared
	var hasAccess bool
	err = r.DB.QueryRow(`
			SELECT EXISTS (
				SELECT 1 FROM files f
				WHERE f.id = $1 AND (
					f.owner = $2 OR EXISTS (
						SELECT 1 FROM shared_file sf WHERE sf.file_id = $1 AND sf.user_id = $2
					)
				)
			)
		`, fileUUID, userID).Scan(&hasAccess)

	if err != nil || !hasAccess {
		return nil, fmt.Errorf("unauthorized")
	}

	// Update content
	_, err = r.DB.Exec(`UPDATE files SET content = $1 WHERE id = $2`, content, fileUUID)
	if err != nil {
		return nil, fmt.Errorf("failed to update content")
	}

	// Return updated file
	var file model.File
	err = r.DB.QueryRow(`
			SELECT id, name, owner, created_at, is_public, content
			FROM files
			WHERE id = $1`, fileUUID).Scan(
		&file.ID, &file.Name, &file.Owner, &file.CreatedAt, &file.IsPublic, &file.Content,
	)

	if err != nil {
		return nil, fmt.Errorf("failed to fetch updated file")
	}

	return &file, nil
}

// DeleteFile is the resolver for the deleteFile field.
func (r *mutationResolver) DeleteFile(ctx context.Context, fileID string) (bool, error) {
	userID, ok := auth.ForContext(ctx)
	if !ok {
		return false, fmt.Errorf("authentication required")
	}

	fileUUID, err := uuid.Parse(fileID)
	if err != nil {
		return false, fmt.Errorf("invalid file ID")
	}

	// Start transaction
	tx, err := r.DB.Begin()
	if err != nil {
		return false, fmt.Errorf("failed to start transaction")
	}
	defer tx.Rollback()

	// Verify ownership
	var isOwner bool
	err = tx.QueryRow(`
        SELECT EXISTS (
            SELECT 1 FROM files
            WHERE id = $1 AND owner = $2
        )`, fileUUID, userID).Scan(&isOwner)
	if err != nil || !isOwner {
		return false, fmt.Errorf("unauthorized: only owner can delete file")
	}

	// Delete from shared_file first
	_, err = tx.Exec(`DELETE FROM shared_file WHERE file_id = $1`, fileUUID)
	if err != nil {
		return false, fmt.Errorf("failed to delete shared links")
	}

	// Then delete the file
	_, err = tx.Exec(`DELETE FROM files WHERE id = $1`, fileUUID)
	if err != nil {
		return false, fmt.Errorf("failed to delete file")
	}

	// Commit transaction
	if err := tx.Commit(); err != nil {
		return false, fmt.Errorf("failed to commit transaction")
	}

	return true, nil
}

// ShareFile is the resolver for the shareFile field.
func (r *mutationResolver) ShareFile(ctx context.Context, fileID string, userID string) (bool, error) {
	currentUserID, ok := auth.ForContext(ctx)
	if !ok {
		return false, fmt.Errorf("authentication required")
	}

	fileUUID, err := uuid.Parse(fileID)
	if err != nil {
		return false, fmt.Errorf("invalid file ID")
	}

	userUUID, err := uuid.Parse(userID)
	if err != nil {
		return false, fmt.Errorf("invalid user ID")
	}

	// Verify if the current user is the owner of the file
	var isOwner bool
	err = r.DB.QueryRow(`
        SELECT EXISTS (
            SELECT 1 FROM files
            WHERE id = $1 AND owner = $2
        )`, fileUUID, currentUserID).Scan(&isOwner)
	if err != nil || !isOwner {
		return false, fmt.Errorf("unauthorized: only owner can share the file")
	}

	// Check if the user has already been shared the file
	var alreadyShared bool
	err = r.DB.QueryRow(`
        SELECT EXISTS (
            SELECT 1 FROM shared_file
            WHERE file_id = $1 AND user_id = $2
        )`, fileUUID, userUUID).Scan(&alreadyShared)
	if err != nil {
		return false, fmt.Errorf("failed to check if file is already shared")
	}

	if alreadyShared {
		return false, fmt.Errorf("file already shared with this user")
	}

	// Insert the share record
	_, err = r.DB.Exec(`
        INSERT INTO shared_file (file_id, user_id)
        VALUES ($1, $2)`, fileUUID, userUUID)
	if err != nil {
		return false, fmt.Errorf("failed to share file")
	}

	return true, nil
}

// MakeFilePublic is the resolver for the makeFilePublic field.
func (r *mutationResolver) MakeFilePublic(ctx context.Context, fileID string) (bool, error) {
	currentUserID, ok := auth.ForContext(ctx)
	if !ok {
		return false, fmt.Errorf("authentication required")
	}

	fileUUID, err := uuid.Parse(fileID)
	if err != nil {
		return false, fmt.Errorf("invalid file ID")
	}

	// Verify if the current user is the owner of the file
	var isOwner bool
	err = r.DB.QueryRow(`
        SELECT EXISTS (
            SELECT 1 FROM files
            WHERE id = $1 AND owner = $2
        )`, fileUUID, currentUserID).Scan(&isOwner)
	if err != nil || !isOwner {
		return false, fmt.Errorf("unauthorized: only owner can make file public")
	}

	// Update the file's "is_public" field to true
	_, err = r.DB.Exec(`
        UPDATE files SET is_public = true
        WHERE id = $1`, fileUUID)
	if err != nil {
		return false, fmt.Errorf("failed to make file public")
	}

	return true, nil
}

// RevokeShare is the resolver for the revokeShare field.
func (r *mutationResolver) RevokeShare(ctx context.Context, fileID string, userID string) (bool, error) {
	currentUserID, ok := auth.ForContext(ctx)
	if !ok {
		return false, fmt.Errorf("authentication required")
	}

	fileUUID, err := uuid.Parse(fileID)
	if err != nil {
		return false, fmt.Errorf("invalid file ID")
	}

	userUUID, err := uuid.Parse(userID)
	if err != nil {
		return false, fmt.Errorf("invalid user ID")
	}

	// Verify if the current user is the owner of the file
	var isOwner bool
	err = r.DB.QueryRow(`
        SELECT EXISTS (
            SELECT 1 FROM files
            WHERE id = $1 AND owner = $2
        )`, fileUUID, currentUserID).Scan(&isOwner)
	if err != nil || !isOwner {
		return false, fmt.Errorf("unauthorized: only owner can revoke share")
	}

	// Check if the file is shared with the user
	var shared bool
	err = r.DB.QueryRow(`
        SELECT EXISTS (
            SELECT 1 FROM shared_file
            WHERE file_id = $1 AND user_id = $2
        )`, fileUUID, userUUID).Scan(&shared)
	if err != nil || !shared {
		return false, fmt.Errorf("file is not shared with this user")
	}

	// Delete the share record
	_, err = r.DB.Exec(`
        DELETE FROM shared_file
        WHERE file_id = $1 AND user_id = $2`, fileUUID, userUUID)
	if err != nil {
		return false, fmt.Errorf("failed to revoke share")
	}

	return true, nil
}

// User is the resolver for the User field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	userUUID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid user UUID")
	}

	var user model.User
	err = r.DB.QueryRow(`
        SELECT id, usernamename, created_at
        FROM users
        WHERE id = $1`, userUUID).Scan(&user.ID, &user.Username, &user.CreatedAt)
	if err != nil {
		return nil, err
	}
	return &user, nil
}

// Files is the resolver for the files field.
func (r *queryResolver) Files(ctx context.Context, owner string) ([]*model.File, error) {
	ownerUUID, err := uuid.Parse(owner)
	if err != nil {
		return nil, fmt.Errorf("invalid owner UUID")
	}

	rows, err := r.DB.Query(`
		SELECT id, name, owner, created_at, is_public
		FROM files
		WHERE owner = $1`, ownerUUID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var files []*model.File
	for rows.Next() {
		var file model.File
		err := rows.Scan(&file.ID, &file.Name, &file.Owner, &file.CreatedAt, &file.IsPublic)
		if err != nil {
			return nil, err
		}
		files = append(files, &file)
	}
	return files, nil
}

// File is the resolver for the file field.
func (r *queryResolver) File(ctx context.Context, fileID string) (*model.File, error) {
	fileUUID, err := uuid.Parse(fileID)
	if err != nil {
		return nil, fmt.Errorf("invalid file ID")
	}

	// First check if file is public
	var isPublic bool
	err = r.DB.QueryRow(`
		SELECT is_public FROM files WHERE id = $1
	`, fileUUID).Scan(&isPublic)

	if err != nil {
		return nil, fmt.Errorf("file not found")
	}

	// If file is public, return it without further checks
	if isPublic {
		row := r.DB.QueryRow(`
			SELECT id, name, owner, created_at, content, is_public
			FROM files
			WHERE id = $1
		`, fileUUID)

		var file model.File
		if err := row.Scan(&file.ID, &file.Name, &file.Owner, &file.CreatedAt, &file.Content, &file.IsPublic); err != nil {
			return nil, fmt.Errorf("failed to fetch public file")
		}
		return &file, nil
	}

	// For private files, proceed with normal auth checks
	userID, ok := auth.ForContext(ctx)
	if !ok {
		return nil, fmt.Errorf("authentication required for private files")
	}

	query := `
		SELECT id, name, owner, created_at, content, is_public
		FROM files
		WHERE id = $1 AND (owner = $2 OR EXISTS (
			SELECT 1 FROM shared_file
			WHERE file_id = $1 AND user_id = $2
		))
	`

	row := r.DB.QueryRow(query, fileUUID, userID)
	var file model.File
	if err := row.Scan(&file.ID, &file.Name, &file.Owner, &file.CreatedAt, &file.Content, &file.IsPublic); err != nil {
		return nil, fmt.Errorf("file not found or unauthorized")
	}

	return &file, nil
}

// SharedFiles is the resolver for the sharedFiles field.
func (r *queryResolver) SharedFiles(ctx context.Context) ([]*model.File, error) {
	userID, ok := auth.ForContext(ctx)
	if !ok {
		return nil, fmt.Errorf("authentication required")
	}

	rows, err := r.DB.Query(`
        SELECT f.id, f.name, f.owner, f.created_at, f.is_public
        FROM shared_file sf
        JOIN files f ON sf.file_id = f.id
        WHERE sf.user_id = $1 AND f.owner != $1`,
		userID,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to query shared files")
	}
	defer rows.Close()

	var files []*model.File
	for rows.Next() {
		var file model.File
		if err := rows.Scan(
			&file.ID,
			&file.Name,
			&file.Owner,
			&file.CreatedAt,
			&file.IsPublic,
		); err != nil {
			return nil, err
		}
		files = append(files, &file)
	}
	return files, nil
}

// SharedUsers is the resolver for the sharedUsers field.
func (r *queryResolver) SharedUsers(ctx context.Context, fileID string) ([]*model.User, error) {
	// Query to get user IDs from the shared_files table
	rows, err := r.DB.QueryContext(ctx, `
        SELECT user_id
        FROM shared_files
        WHERE file_id = $1
    `, fileID)
	if err != nil {
		return nil, fmt.Errorf("error fetching shared user IDs: %w", err)
	}
	defer rows.Close()

	var userIDs []string
	for rows.Next() {
		var uid string
		if err := rows.Scan(&uid); err != nil {
			return nil, fmt.Errorf("error scanning user_id: %w", err)
		}
		userIDs = append(userIDs, uid)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("row iteration error: %w", err)
	}

	if len(userIDs) == 0 {
		return []*model.User{}, nil // no users shared
	}

	// Fetch user details based on the collected user IDs
	query := `
        SELECT id, username, created_at
        FROM users
        WHERE id = ANY($1)
    `
	usersRows, err := r.DB.QueryContext(ctx, query, pq.Array(userIDs))
	if err != nil {
		return nil, fmt.Errorf("error fetching users: %w", err)
	}
	defer usersRows.Close()

	var users []*model.User
	for usersRows.Next() {
		var u model.User
		if err := usersRows.Scan(&u.ID, &u.Username, &u.CreatedAt); err != nil {
			return nil, fmt.Errorf("error scanning user: %w", err)
		}
		users = append(users, &u)
	}

	if err := usersRows.Err(); err != nil {
		return nil, fmt.Errorf("user row iteration error: %w", err)
	}

	return users, nil
}

// MyFiles is the resolver for the myFiles field.
func (r *queryResolver) MyFiles(ctx context.Context) ([]*model.File, error) {
	userID, ok := auth.ForContext(ctx)
	if !ok {
		return nil, fmt.Errorf("authentication required")
	}

	userUUID, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID")
	}

	rows, err := r.DB.Query(`
		SELECT f.id, f.name, f.owner, f.created_at, f.is_public
		FROM files f
		LEFT JOIN shared_file sf ON f.id = sf.file_id
		WHERE f.owner = $1 OR sf.user_id = $1`,
		userUUID,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to query files")
	}
	defer rows.Close()

	var files []*model.File
	for rows.Next() {
		var file model.File
		if err := rows.Scan(
			&file.ID,
			&file.Name,
			&file.Owner,
			&file.CreatedAt,
			&file.IsPublic,
		); err != nil {
			return nil, err
		}
		files = append(files, &file)
	}
	return files, nil
}

// PublicFiles is the resolver for the publicFiles field.
func (r *queryResolver) PublicFiles(ctx context.Context) ([]*model.File, error) {
	rows, err := r.DB.Query(`
        SELECT id, name, owner, created_at, is_public
        FROM files
        WHERE is_public = true`)
	if err != nil {
		return nil, fmt.Errorf("failed to query public files")
	}
	defer rows.Close()

	var files []*model.File
	for rows.Next() {
		var file model.File
		if err := rows.Scan(
			&file.ID,
			&file.Name,

			&file.Owner,
			&file.CreatedAt,
			&file.IsPublic,
		); err != nil {
			return nil, err
		}
		files = append(files, &file)
	}
	return files, nil
}

// PublicFile is the resolver for the publicFile field.
func (r *queryResolver) PublicFile(ctx context.Context, fileID string) (*model.File, error) {
	fileUUID, err := uuid.Parse(fileID)
	if err != nil {
		return nil, fmt.Errorf("invalid file ID")
	}

	var file model.File
	err = r.DB.QueryRow(`
			SELECT id, name, owner, created_at, content, is_public
			FROM files
			WHERE id = $1 AND is_public = true
		`, fileUUID).Scan(
		&file.ID,
		&file.Name,
		&file.Owner,
		&file.CreatedAt,
		&file.Content,
		&file.IsPublic,
	)

	if err != nil {
		return nil, fmt.Errorf("public file not found")
	}

	return &file, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
